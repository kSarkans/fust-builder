#!/usr/bin/env python

# ----------------------------------------------------------------
# |                     ~  ~~ ~~~ ~~  ~                          |
# |             ~  ~~ ~~~ Fust Builder ~~~ ~~  ~                 |
# |                     ~  ~~ ~~~ ~~  ~                          |
# |                      Created by Sarkans (Sergei Vishnevecki) |
# |                                                 License: MIT |
# |                                                              |
# |--------------------------------------------------------------|
# |                                                              |
# | This script was created because I was sick of writing        |
# | a separate Bash file for each new C/C++ project that         |
# | would compile my project (not to mention manual compilation, |
# | entering command after command in the terminal).             |
# | If you find this script useful, use it in good health.       |
# |                                                              |
# ----------------------------------------------------------------

import os
import sys
import configparser

# Styles
S0 = '\033[0m'
SBLD = '\033[1m'
SITL = '\033[3m'

# Colors
CRED = '\033[31m'
CGRN = '\033[32m'
CYLW = '\033[33m'
CBLU = '\033[34m'
CPRP = '\033[35m'
CCYN = '\033[36m'

# Variables
_VERSION = '1.4'
global path
global exe_name
global path_src
global path_lib
global path_build
global comp_args

# Return a success or an error
def rtn(code, msg, makeReturn = False):
    # Error codes:
    # 1   --  Unexcepted error.
    # 2   --  No such directory.
    # 3   --  Compiler is not definied.
    # 4   --  There is no compiler named.
    # 5   --  Invalid argument.
    # 6   --  No argument.
    # 7   --  There is no third argument to the compiler.
    # 8   --  The executable was not compiled.
    # 9   --  Wrong option.
    # 10  --  Invalid syntax.
    # 11  --  Permission denied.

    MSG     = '['+CYLW+'M'+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    MSG_SUC = '['+CGRN+str(code)+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    MSG_ERR = '['+CRED+str(code)+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    
    if code == 0:
        print(MSG_SUC + CGRN + msg + S0)
        if makeReturn:
            sys.exit(0)
    elif code == 'M':
        print(MSG + msg)
    else:
        print(MSG_ERR + CRED + msg + S0)
        sys.exit(code)

# Show me the help message!
def help():
    print(CYLW+SBLD+'\nFust Builder manual\n'+S0)

    print('example: ' + SBLD + 'fust debug g++ -Wall -lm --exe=myprog' + S0)
    print('fust '+CCYN+'[ARGUMENT_1] '+CPRP+'[ARGUMENT_2] '+CBLU+SITL+'[OPTIONS]'+S0+':')

    print(CCYN+'\t[ARGUMENT_1]'+S0+':')
    print('\t\t'+CYLW+'help'+S0+'\t  ---   Display this manual.')
    print('\t\t'+CYLW+'├─ --help'+S0)
    print('\t\t'+CYLW+'└─ -h'+S0)
    print('\t\t'+CYLW+'mkconfig'+S0+'  ---   Create a project config file. '+CRED+SBLD+'Will override existing file!'+S0)
    print('\t\t'+CYLW+'debug'+S0+'\t  ---   Perform debugging. Creates an executable file in the project folder at \'project-path/build/\' and runs it immediately.')
    print('\t\t'+CYLW+'pdebug'+S0+'\t  ---   Pure debugging. Does the same as \'debug\', but leaves no executable files behind.')
    print('\t\t'+CYLW+'build'+S0+'\t  ---   Builds the project into an executable file at \'project-path/build/\'.')
    print('\t\t'+CYLW+'version'+S0+'\t  ---   Show current Fust version')
    print('\t\t'+CYLW+'├─ --version'+S0)
    print('\t\t'+CYLW+'└─ -v'+S0)

    print(CPRP+'\t[ARGUMENT_2]'+S0+':')
    print('\t\t'+CYLW+'gcc'+S0+'\t  ---   Use gcc as compiler.')
    print('\t\t'+CYLW+'g++'+S0+'\t  ---   Use g++ as compiler.')
    print('\t\t'+CYLW+'clang'+S0+'\t  ---   Use clang as compiler.')
    print('\t\t'+CYLW+'clang++'+S0+'\t  ---   Use clang++ as compiler.')
    print('\t\t'+CYLW+SITL+'path'+S0+'\t  ---   The path '+SBLD+'(eg /home/user/project)'+S0+' is specified to \'mkconfig\' in the first argument if you want to specify a different path for the config file than the one you are currently in. ')

    print(CBLU+SITL+'\t[OPTIONS]'+S0+':')
    print('\t\t'+CYLW+SITL+'compiler options'+S0+'   ---   Additional compiler options, such as -Wall, -lm, etc.')
    print('\t\t'+CYLW+'--path='+SITL+'dir'+S0+'\t   ---   Use a specific project path instead of the current path in the terminal or specified in the config file.'+S0)
    print('\t\t'+CYLW+'--exe='+SITL+'name'+S0+'\t   ---   Use a specific executable name instead of default or specified in the config file.'+S0)
    print('\t\t'+CYLW+'--src='+SITL+'local_dir'+S0+'\t   ---   Use a specific source path instead of default or specified in the config file.'+S0)
    print('\t\t'+CYLW+'--lib='+SITL+'local_dir'+S0+'\t   ---   Use a specific library path instead of default or specified in the config file.'+S0)
    print('\t\t'+CYLW+'--bin='+SITL+'local_dir'+S0+'\t   ---   Use a specific build path instead of default or specified in the config file.'+S0)

# Trying to load a config
def loadconfig():
    config = configparser.ConfigParser()
    global path
    global exe_name
    global path_src
    global path_lib
    global path_build
    global comp_args

    # Try to get config. If failed then load default values
    try:
        config.read('fust.config')

        try:
            path = config.get('Project', 'path')
        except:
            path = os.getcwd()

        try:
            exe_name = config.get('Project', 'exe')
        except:
            exe_name = 'a.out'

        try:
            path_src = config.get('Project', 'src')
        except:
            path_src = 'src'

        try:
            path_lib = config.get('Project', 'lib')
        except:
            path_lib = 'lib'

        try:
            path_build = config.get('Project', 'bin')
        except:
            path_build = 'bin'

        try:
            comp_args = config.get('Project', 'args')
        except:
            comp_args = ''
    except:
        path = os.getcwd()
        exe_name = 'a.out'
        path_src = 'src'
        path_lib = 'lib'
        path_build = 'bin'
        comp_args = ''

# Make a specific config file for your project
def mkconfig(conf_path):
    try:
        _f = open(conf_path + '/fust.config', 'w')
        _f.write('[Project]\n; Directory to your project. By default, this is the directory from which you run fust.\n;path = /home/user/project\n\n; The name of the executable file to be compiled.\nexe = a.out\n\n; The name of the folder where the source files are stored in your project directory.\nsrc = src\n\n; The name of the folder where header files are stored in your project directory.\nlib = lib\n\n; The name of the folder where your project will be compiled.\nbin = bin\n\n; Compiler arguments\n;args = -Wall -lm')
        _f.close()
        rtn(0, 'Config created at \''+conf_path+'/fust.config\'')
    except PermissionError:
        rtn(11, 'Permission denied: \''+conf_path+'/fust.config\'.')
    except:
        rtn(1, 'Unexcepted error.')

# Let's build our project!
def build(compiler):
    global path
    global exe_name
    global path_src
    global path_lib
    global path_build
    global comp_args

    for i in range(3, len(sys.argv)):
        r = sys.argv[i]
        if r[0] == '-':
            if r[1] == '-' and r[2] == 'e' and r[3] == 'x' and r[4] == 'e' and r[5] == '=':
                print('EXE OPTION CHECKED!!!')
                exe_name = ''
                for j in range(6, len(r)):
                    exe_name += r[j]
            elif r[1] == '-' and r[2] == 'p' and r[3] == 'a' and r[4] == 't' and r[5] == 'h' and r[6] == '=':
                path = ''
                for j in range(7, len(r)):
                    path += r[j]
            elif r[1] == '-' and r[2] == 's' and r[3] == 'r' and r[4] == 'c' and r[5] == '=':
                path_src = ''
                for j in range(6, len(r)):
                    path_src += r[j]
            elif r[1] == '-' and r[2] == 'l' and r[3] == 'i' and r[4] == 'b' and r[5] == '=':
                path_lib = ''
                for j in range(6, len(r)):
                    path_lib += r[j]
            elif r[1] == '-' and r[2] == 'b' and r[3] == 'i' and r[4] == 'n' and r[5] == '=':
                path_build = ''
                for j in range(6, len(r)):
                    path_build += r[j]
            else:
                comp_args += ' ' + r
        else:
            rtn(10, 'Invalid syntax. \''+r+'\': options must start with - or --.  Type \'fust help\' to display manual.')

    if sys.argv[1] != 'pdebug':
        rtn('M', 'Trying to compile code into \'' + path + '/' + path_build+'/'+exe_name+'\'')
        print(compiler+' -o '+path+'/'+path_build+'/'+exe_name+' -I '+path+'/'+path_lib+' -g '+path+'/'+path_src+'/*.c* '+comp_args)
        os.system('mkdir -p ' + path + '/' + path_build)
        if not os.system(compiler+' -o '+path+'/'+path_build+'/'+exe_name+' -I '+path+'/'+path_lib+' -g '+path+'/'+path_src+'/*.c* '+comp_args):
            os.system('chmod +x '+path+'/'+path_build+'/'+exe_name)
            rtn(0, 'The executable was compiled at path: \''+path+'/'+path_build+'/'+exe_name+'\'')
        else:
            rtn(8, 'The executable was not compiled.')
    else:
        rtn('M', 'Trying to compile code into \'' + path + '/'+exe_name+'\'')
        print(compiler+' -o '+path+'/'+exe_name+' -I '+path+'/'+path_lib+' -g '+path+'/'+path_src+'/*.c* '+comp_args)
        if not os.system(compiler+' -o '+path+'/'+exe_name+' -I '+path+'/'+path_lib+' -g '+path+'/'+path_src+'/*.c* '+comp_args):
            os.system('chmod +x '+path+'/'+exe_name)
            rtn(0, 'The executable was compiled at path: \''+path+'/'+exe_name+'\'')
        else:
            rtn(8, 'The executable was not compiled.')

# Test it (1)
def debug(compiler):
    try:
        build(compiler)
        rtn('M', 'Trying to start executable at \''+path+'/'+path_build+'/'+exe_name+'\'...\n')
        if not os.system(path+'/'+path_build+'/'+exe_name):
            print('')
            rtn(0, 'Success!', True)
        else:
            print('')
            rtn(1, 'Something gone wrong...')
    except not sys.exit():
        rtn(7, 'There is no third argument to the compiler.')

# Test it (2)
def pdebug(compiler):
    try:
        build(compiler)
        rtn('M', 'Trying to start executable at \''+path+'/'+exe_name+'\'...\n')
        if not os.system(path+'/'+exe_name):
            os.system('rm '+path+'/'+exe_name)
            print('')
            rtn(0, 'Success!', True)
        else:
            print('')
            rtn(1, 'Something gone wrong...')
    except not sys.exit():
        rtn(7, 'There is no third argument to the compiler.')

# Let's goooo
def main():
    loadconfig()

    # God, why does not Python have switch-case?
    if len(sys.argv) > 1:
        if sys.argv[1] == 'help' or sys.argv[1] == '--help' or sys.argv[1] == '-h':
            help()
        elif sys.argv[1] == 'mkconfig':
            if len(sys.argv) > 2 and sys.argv[2] != None:
                try:
                    mkconfig(str(sys.argv[2]))
                except FileNotFoundError:
                    rtn(2, 'No such directory \''+str(sys.argv[2])+'\'')
                except:
                    rtn(1, 'Unexcepted error.')
            else:
                mkconfig(os.getcwd())
        elif sys.argv[1] == 'build':
            if len(sys.argv) < 3:
                rtn(3, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    build('g++')
                elif sys.argv[2] == 'gcc':
                    build('gcc')
                elif sys.argv[2] == 'clang':
                    build('clang')
                elif sys.argv[2] == 'clang++':
                    build('clang++')
                else:
                    rtn(4, 'There is no compiler named \''+sys.argv[2]+'\'.')
        elif sys.argv[1] == 'debug':
            if len(sys.argv) < 3:
                rtn(3, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    debug('g++')
                elif sys.argv[2] == 'gcc':
                    debug('gcc')
                elif sys.argv[2] == 'clang':
                    debug('clang')
                elif sys.argv[2] == 'clang++':
                    debug('clang++')
                else:
                    rtn(4, 'There is no compiler named \''+sys.argv[2]+'\'.')
        elif sys.argv[1] == 'pdebug':
            if len(sys.argv) < 3:
                rtn(3, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    pdebug('g++')
                elif sys.argv[2] == 'gcc':
                    pdebug('gcc')
                elif sys.argv[2] == 'clang':
                    pdebug('clang')
                elif sys.argv[2] == 'clang++':
                    pdebug('clang++')
                else:
                    rtn(4, 'There is no compiler named \''+sys.argv[2]+'\'.')
        elif sys.argv[1] == 'version' or sys.argv[1] == '--version' or sys.argv[1] == '-v':
            print('Fust v' + _VERSION)
        else:
            rtn(5, 'Invalid argument \''+sys.argv[1]+'\'. Type \'fust help\' to display manual.')
    elif len(sys.argv) < 2:
        rtn(6, 'No argument. Type \'fust help\' to display manual.')

if __name__ == '__main__':
    sys.exit(main())