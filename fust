#!/usr/bin/env python

# ---------------------------------------------------------------|
# |                     ~  ~~ ~~~ ~~  ~                          |
# |             ~  ~~ ~~~ Fust Builder ~~~ ~~  ~                 |
# |                     ~  ~~ ~~~ ~~  ~                          |
# |                      Created by Sarkans (Sergei Vishnevecki) |
# |                                                 License: MIT |
# |                                                              |
# ---------------------------------------------------------------|
# |                                                              |
# | This script was created because I was sick of writing        |
# | a separate Bash file for each new C/C++ project that         |
# | would compile my project (not to mention manual compilation, |
# | entering command after command in the terminal).             |
# | If you find this script useful, use it in good health.       |
# |                                                              |
# ---------------------------------------------------------------|

# TODO: Add argument parser for human beings
import os
import sys
import configparser

# Styles
S0 = '\033[0m'
SBLD = '\033[1m'
SITL = '\033[3m'

# Colors
CRED = '\033[31m'
CGRN = '\033[32m'
CBLU = '\033[34m'
CPRP = '\033[35m'
CCYN = '\033[36m'
CYLW = '\033[33m'

# Variables
limArg = 4
global path
global exe_name
global path_src
global path_lib
global path_build

# Return a success or an error
def rtn(code, msg):
    MSG = '['+CYLW+'M'+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    MSG_SUC = '['+CGRN+str(code)+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    MSG_ERR = '['+CRED+str(code)+S0+'] '+CYLW+SBLD+'Fust'+S0+': '
    
    if code == 0:
        print(MSG_SUC + CGRN + msg + S0)
    elif code == 2:
        print(MSG + msg)
    else:
        print(MSG_ERR + CRED + msg + S0)

# Show me the help message!
def help():
    print(CYLW+SBLD+'Fust Builder manual\n'+S0)

    print('fust '+CCYN+'[ARGUMENT_1] '+CPRP+'[ARGUMENT_2] '+CBLU+SITL+'[OPTIONS]'+S0+':')

    print(CCYN+'\t[ARGUMENT_1]'+S0+':')
    print('\t\t'+CYLW+'help'+S0+'\t  ---   Display this manual.')
    print('\t\t'+CYLW+'mkconfig'+S0+'  ---   Create a project config file. '+CRED+SBLD+'Will override existing file!'+S0)
    print('\t\t'+CYLW+'debug'+S0+'\t  ---   Perform debugging. Creates an executable file in the project folder at \'project-path/build/\' and runs it immediately.')
    print('\t\t'+CYLW+'pdebug'+S0+'\t  ---   Pure debugging. Does the same as \'debug\', but leaves no executable files behind.')
    print('\t\t'+CYLW+'build'+S0+'\t  ---   Builds the project into an executable file at \'project-path/build/\'.')

    print(CPRP+'\t[ARGUMENT_2]'+S0+':')
    print('\t\t'+CYLW+'gcc'+S0+'\t  ---   Use gcc as compiler.')
    print('\t\t'+CYLW+'g++'+S0+'\t  ---   Use g++ as compiler.')
    print('\t\t'+CYLW+SITL+'path'+S0+'\t  ---   The path '+SBLD+'(eg /home/user/project)'+S0+' is specified to \'mkconfig\' in the first argument if you want to specify a different path for the config file than the one you are currently in. ')

    print(CBLU+SITL+'\t[OPTIONS]'+S0+':')
    print('\t\t'+CYLW+SITL+'compiler options'+S0+'   ---   Additional compiler options, such as -lm. '+SBLD+'To enter multiple options, use quotes like \'-lm -Wall\' or "-lm -Wall".'+S0)

# Trying to load a config
def loadconfig():
    config = configparser.ConfigParser()
    global path
    global exe_name
    global path_src
    global path_lib
    global path_build

    # Try to get config. If failed then load default values
    try:
        config.read('fust.config')

        try:
            path = config.get('Project', 'path')
        except:
            path = os.getcwd()

        try:
            exe_name = config.get('Project', 'exe')
        except:
            exe_name = 'a.out'

        try:
            path_src = config.get('Project', 'src')
        except:
            path_src = 'src'

        try:
            path_lib = config.get('Project', 'lib')
        except:
            path_lib = 'lib'

        try:
            path_build = config.get('Project', 'bin')
        except:
            path_build = 'bin'
    except:
        path = os.getcwd()
        exe_name = 'a.out'
        path_src = 'src'
        path_lib = 'lib'
        path_build = 'bin'

# Make a specific config file for your project
def mkconfig(conf_path):
    try:
        _f = open(conf_path + '/fust.config', 'w')
        _f.write('[Project]\n; Directory to your project. By default, this is the directory from which you run fust.\n;path = /home/user/project\n\n; The name of the executable file to be compiled.\nexe = a.out\n\n; The name of the folder where the source files are stored in your project directory.\nsrc = src\n\n; The name of the folder where header files are stored in your project directory.\nlib = lib\n\n; The name of the folder where your project will be compiled.\nbin = bin')
        _f.close()
        rtn(0, 'Config created at \''+conf_path+'/fust.config\'')
    except PermissionError:
        rtn(1, 'Permission denied: \''+conf_path+'/fust.config\'.')
    except:
        rtn(1, 'Unexcepted error.')

# Let's build our project!
def build(compiler):
    global path
    global exe_name
    global path_src
    global path_lib
    global path_build

    if sys.argv[1] != 'pdebug':
        rtn(2, 'Trying to compile code into \'' + path + '/' + path_build+'/'+exe_name+'\'')
        os.system('mkdir -p ' + path + '/' + path_build)
        if len(sys.argv) > 3:
            if not os.system(compiler+' -o '+path+'/'+path_build+'/'+exe_name+' -Wall -I '+path+'/'+path_lib+' '+path+'/'+path_src+'/*.c* '+sys.argv[3]):
                os.system('chmod +x '+path+'/'+path_build+'/'+exe_name)
                rtn(0, 'The executable was compiled at path: \''+path+'/'+path_build+'/'+exe_name+'\'')
            else:
                rtn(1, 'The executable was not compiled.')
                sys.exit()
        else:
            if not os.system(compiler+' -o '+path+'/'+path_build+'/'+exe_name+' -Wall -I '+path+'/'+path_lib+' '+path+'/'+path_src+'/*.c*'):
                os.system('chmod +x '+path+'/'+path_build+'/'+exe_name)
                rtn(0, 'The executable was compiled at path: \''+path+'/'+path_build+'/'+exe_name+'\'')
            else:
                rtn(1, 'The executable was not compiled.')
                sys.exit()
    else:
        rtn(2, 'Trying to compile code into \'' + path + '/'+exe_name+'\'')
        if len(sys.argv) > 3:
            if not os.system(compiler+' -o '+path+'/'+exe_name+' -Wall -I '+path+'/'+path_lib+' '+path+'/'+path_src+'/*.c* '+sys.argv[3]):
                os.system('chmod +x '+path+'/'+exe_name)
                rtn(0, 'The executable was compiled at path: \''+path+'/'+exe_name+'\'')
            else:
                rtn(1, 'The executable was not compiled.')
                sys.exit()
        else:
            if not os.system(compiler+' -o '+path+'/'+exe_name+' -Wall -I '+path+'/'+path_lib+' '+path+'/'+path_src+'/*.c*'):
                os.system('chmod +x '+path+'/'+exe_name)
                rtn(0, 'The executable was compiled at path: \''+path+'/'+exe_name+'\'')
            else:
                rtn(1, 'The executable was not compiled.')
                sys.exit()

# Test it (1)
def debug(compiler):
    try:
        build(compiler)
        rtn(2, 'Trying to start executable at \''+path+'/'+path_build+'/'+exe_name+'\'...\n')
        if not os.system(path+'/'+path_build+'/'+exe_name):
            print('')
            rtn(0, 'Success!')
        else:
            print('')
            rtn(1, 'Something gone wrong...')
    except not sys.exit():
        rtn(1, 'There is no third argument to the compiler.')

# Test it (2)
def pdebug(compiler):
    try:
        build(compiler)
        rtn(2, 'Trying to start executable at \''+path+'/'+exe_name+'\'...\n')
        if not os.system(path+'/'+exe_name):
            os.system('rm '+path+'/'+exe_name)
            print('')
            rtn(0, 'Success!')
        else:
            print('')
            rtn(1, 'Something gone wrong...')
    except not sys.exit():
        rtn(1, 'There is no third argument to the compiler.')

# Let's goooo
def main():
    loadconfig()

    # God, why does not Python have switch-case?
    if len(sys.argv) > 1 and len(sys.argv) < limArg:
        if sys.argv[1] == 'help':
            help()
        elif sys.argv[1] == 'mkconfig':
            if len(sys.argv) > 2 and sys.argv[2] != None:
                try:
                    mkconfig(str(sys.argv[2]))
                except FileNotFoundError:
                    rtn(1, 'No such directory \''+str(sys.argv[2])+'\'')
                except:
                    rtn(1, 'Unexcepted error.')
            else:
                mkconfig(os.getcwd())
        elif sys.argv[1] == 'build':
            if len(sys.argv) < 3:
                rtn(1, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    build('g++')
                elif sys.argv[2] == 'gcc':
                    build('gcc')
                else:
                    rtn(1, 'There is no compiler named \''+sys.argv[2]+'\'.')
        elif sys.argv[1] == 'debug':
            if len(sys.argv) < 3:
                rtn(1, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    debug('g++')
                elif sys.argv[2] == 'gcc':
                    debug('gcc')
                else:
                    rtn(1, 'There is no compiler named \''+sys.argv[2]+'\'.')
        elif sys.argv[1] == 'pdebug':
            if len(sys.argv) < 3:
                rtn(1, 'Compiler is not definied.')
            else:
                if sys.argv[2] == 'g++':
                    pdebug('g++')
                elif sys.argv[2] == 'gcc':
                    pdebug('gcc')
                else:
                    rtn(1, 'There is no compiler named \''+sys.argv[2]+'\'.')
        else:
            rtn(1, 'Invalid argument \''+sys.argv[1]+'\'. Type \'fust help\' to display manual.')
    elif len(sys.argv) < 2:
        rtn(1, 'No argument. Type \'fust help\' to display manual.')
    elif len(sys.argv) >= limArg:
        rtn(1, 'Too many arguments ('+str(len(sys.argv))+'). Type \'fust help\' to display manual.')

if __name__ == '__main__':
    main()